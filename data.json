{
  "meta": {
    "total_cards": 186,
    "levels": [
      "lvl_1",
      "lvl_2",
      "lvl_3"
    ],
    "topics": [
      "ML",
      "SQL",
      "Python",
      "Алгоритмы",
      "Статистика",
      "Теория вероятности",
      "A/B тесты",
      "Метрики",
      "Мышление"
    ]
  },
  "cards": [
    {
      "id": 1,
      "question": "Чем отличается INNER JOIN от LEFT JOIN и когда использовать каждый?",
      "answer": "INNER JOIN возвращает только совпадающие строки, LEFT JOIN сохраняет все строки из левой таблицы и добавляет NULL для отсутствующих совпадений в правой, полезно при анализе неполных связей.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 2,
      "question": "Как работает оператор GROUP BY и почему важно добавлять агрегаты к неагрегированным полям?",
      "answer": "GROUP BY это оператор, который собирает строки в группы по указанным полям. Любые другие поля SQL обязан как-то “сжать” с помощью агрегатных функций (SUM, COUNT, MAX, MIN). Поля вне GROUP BY должны быть агрегированы или приведут к ошибке недетерминированности.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 3,
      "question": "Что делает функция ROW_NUMBER() и чем отличается от DENSE_RANK()?",
      "answer": "ROW_NUMBER() это оконная функция, назначает уникальные последовательные номера строкам, строки с одинаковыми значениями получают разные номера; DENSE_RANK() тоже оконная функция, присваивает одинаковый ранг равным значениям и не пропускает ранги.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 4,
      "question": "Объясните разницу между WHERE и HAVING.",
      "answer": "WHERE объявляется и фильтрует строки ДО агрегации (GROUP BY); HAVING фильтрует уже после агрегации - поэтому HAVING может использовать агрегаты.\n\n```sql\nselect customer_id, sum(amount)  \nfrom payments\nwhere amount > 1 \ngroup by customer_id \nhaving sum(amount) > 1000\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 5,
      "question": "Как работает NTILE(N) в оконной функции?",
      "answer": "NTILE(N) упорядочивает строки по указанному полю и делит их на N равномерные группы, где 1-й NTILE для самых маленьких значений, N-й - для самых больших. Хорошо подходит для решения задачи поиска квантилей.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 6,
      "question": "Как использовать CTE (WITH) и зачем они нужны?",
      "answer": "CTE (WITH) нужны, чтобы разбивать сложный запрос на понятные части и переиспользовать промежуточные результаты.\n\n```sql\nwith big_orders as (\n    select *\n    from orders\n    where amount > 500\n)\nselect avg(amount) as avg_big_order\nfrom big_orders\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 7,
      "question": "Что вернёт запрос, который находит пользователей с подряд идущими 3 днями активности?\n\n\n```sql\nWITH ranked AS (\n  SELECT user_id,\n         event_date,\n         ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_date) AS rn\n  FROM activity\n  GROUP BY user_id, event_date\n),\ngroups AS (\n  SELECT user_id,\n         event_date,\n         event_date - rn * INTERVAL '1 day' AS grp_key\n  FROM ranked\n)\nSELECT user_id,\n       MIN(event_date) AS streak_start,\n       MAX(event_date) AS streak_end,\n       COUNT(*) AS days_in_row\nFROM groups\nGROUP BY user_id, grp_key\nHAVING COUNT(*) >= 3;\n```",
      "answer": "Находит всех пользователей с серией минимум из трёх последовательных дней активности и показывает границы серии.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 8,
      "question": "Что такое Метод Монте-Карло?",
      "answer": "Метод Монте-Карло — это метод оценки вероятностей путём многократного случайного моделирования исходов. Вместо точной формулы запускается много случайных \"симуляций\" исходов, и по их результатам считается средний или самый вероятностный исход.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 9,
      "question": "Что такое Расстояние Левенштейна?",
      "answer": "Это алгоритм, определяющий насколько отличаются две строки. Определяет минимальное количество элементарных операций (вставка, удаление, замена символа), необходимых для превращения одной строки в другую.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Алгоритмы"
    },
    {
      "id": 10,
      "question": "Что такое регрессия?",
      "answer": "Регрессия — это метод предсказания числового значения (predict) на основе известных признаков (features). \n\nРегрессия строит математическую модель (прямую или плоскость), которая наилучшим образом описывает зависимости между входными признаками X и выходом y.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 11,
      "question": "Что такое Байесовский классификатор?",
      "answer": "Байесовский классификатор — это метод машинного обучения, который определяет, к какому классу относится объект, исходя из вероятности появления признаков у разных классов. \n\nОн основан на теореме Байеса: \n\n$$\\quad P(Класс \\ | \\ Признаки) = \\frac{P(Признаки \\ | \\ Класс) \\ \\cdot \\ P(Класс)}{P(Признаки)}$$",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 12,
      "question": "Что такое Линейная регрессия?",
      "answer": "Это метод используемый для моделирования линейной зависимости между зависимой переменной и (одной или несколькими) независимыми переменными; Это поиск линейного уравнения, которое наилучшим образом описывает эту взаимосвязь с точки зрения минимизации ошибки между предсказанными и фактическими значениями.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 13,
      "question": "Что такое Нелинейная регрессия?",
      "answer": "Это метод используемый для моделирования линейной зависимости между зависимой переменной и (одной или несколькими) независимыми переменными, когда эти отношения НЕ являются линейными. Например: прогнозирование продаж, учитывающее сезонные колебания.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 14,
      "question": "Что такое Градиентный спуск?",
      "answer": "Градиентный спуск - это метод поиcка минимума функции. Используется, когда найти нули частных производных или применить Δ-тест слишком сложно. Может применяться с большим количеством переменных, с непростыми функциями, и не полными (не точными) данными. Дает приближенный ответ, за очень быстрое время.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 15,
      "question": "Что такое SVD?",
      "answer": "SVD - *Singular Value Decomposition* - «разложение по сингулярным числам».  \nСингулярное разложение матрицы $A$ — это $A = U \\cdot \\Sigma \\cdot V^\\top$  \n- $U$ — матрица левых сингулярных векторов матрицы $A$\n- $\\Sigma$ — диагональная матрица сингулярных чисел матрицы $A$\n- $V$ — матрица правых сингулярных векторов матрицы $A$  \n\nДостоинство сингулярного разложения в том, что оно работает с совершенно любыми матрицами: и вырожденными, и невырожденными, и квадратными, и прямоугольными.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 16,
      "question": "Что такое LSA?",
      "answer": "LSA — *Latent Semantic Analysis* — «латентный семантический анализ». Это подход описывающий объекты векторами и оценивающий сходство по расстоянию между ними. \nС помощью LSA можно решить задачу поиска похожих объектов: сгруппировать отзывы, подобрать похожие товары, рекомендовать фильмы, сегментировать покупателей магазина.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 17,
      "question": "Что такое ЦПТ?",
      "answer": "Центральная предельная теорема — это целый класс теорем, каждый из которых описывает конкретный случай распределения величин $X_i$ и имеет свои условия и ограничения.\n\nЦПТ для суммы. Пусть $X_1, X_2, \\dots, X_n$ — бесконечная последовательность независимых одинаково распределённых случайных величин с математическим ожиданием $μ$ и дисперсией $\\sigma^2$. Определим сумму из $n$ слагаемых величин как $S_n = \\sum_{i=1}^n \\cdot X_i$. Тогда при $n \\to \\infty$ плотность распределения величины $S_n$ будет всё больше похожа на функцию плотности нормального распределения $N(\\mu \\cdot n, \\sigma^2 \\cdot n)$.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Статистика"
    },
    {
      "id": 18,
      "question": "Что такое ММП?",
      "answer": "Метод максимального правдоподобия (ММП) — это метод поиска некоторого параметра $\\theta$, которое наиболее вероятно описывает данные. Работа с ММП требует ручного описания модели, аналитического вывода, и аккуратной реализации в коде.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Статистика"
    },
    {
      "id": 19,
      "question": "Что такое Бутстреп?",
      "answer": "Бутстреп — это метод, который позволяет на основе исходной выборки получить множество новых наборов данных. \n\nПомогает построить доверительные интервалы и понять насколько надёжна оценка некоторой статистики исходной выборки.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Статистика"
    },
    {
      "id": 20,
      "question": "Что такое PCA?",
      "answer": "Метод главных компонент *(PCA - Principal Component Analysis)* — это метод уменьшения размерности, который строит новые оси (главные компоненты) как линейные комбинации исходных признаков. Эти направления выбираются так, чтобы разброс данных вдоль них был максимальным. \n\nДля этого считают матрицу ковариации, находят её собственные значения и собственные векторы, и оставляют компоненты с наибольшими собственными значениями — они содержат большую часть информации. \n\nГлавные компоненты плохо интерпретируемы, так как являются смесью исходных признаков. Сложные нелинейные структуры не уловит.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 21,
      "question": "Что такое Метод t-SNE?",
      "answer": "Метод t-SNE *(t-distributed stochastic neighbor embedding)*  — это нелинейный метод снижения размерности, который сохраняет локальную структуру данных: похожие объекты в новом пространстве оказываются близко, а непохожие — далеко. Метод строит вероятностные распределения расстояний в исходном пространстве и стремится воспроизвести эти отношения в пространстве меньшей размерности. Алгоритм стохастический, поэтому разные запуски дают разные глобальные формы, но локальные группы объектов сохраняются. t-SNE хорошо выявляет кластеры, но плохо передаёт глобальную геометрию и не подходит как метод для последующих ML-моделей.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 22,
      "question": "Что делает оператор CROSS JOIN и когда его используют?",
      "answer": "CROSS JOIN производит декартово произведение двух таблиц. Каждая строка из первой таблицы умножается на каждую строку из второй. Применяется когда нужно получить все возможные комбинации строк двух таблиц.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 23,
      "question": "Когда стоит применять критерий Колмогорова–Смирнова?",
      "answer": "Критерий Колмогорова–Смирнова используют, чтобы проверить:\n\n1. Соответствует ли эмпирическое распределение теоретическому,\n2. Одинаковы ли два непрерывных распределения (две выборки).  \n\nТест сравнивает функции распределения (CDF) и ищет максимальное вертикальное отклонение между ними. Подходит для непрерывных распределений. Не делает предположений о форме. \n\nВ проданалитике часто применяют для сравнения распределений latency до/после релиза, когда важна форма распределения, а не только среднее.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Статистика"
    },
    {
      "id": 24,
      "question": "Что такое PDF и CDF, и чем они отличаются?",
      "answer": "CDF (Cumulative Distribution Function) — функция распределения непрерывной случайной величины. Показывает вероятность того, что X примет значение не больше чем x:\n\n$$ F_X(x) = P(X \\le x)  $$\n\nCDF всегда неубывающая и принимает значения от 0 до 1.\n\nPDF (Probability Density Function) — функция плотности распределения НСВ. Это производная функции распределения:\n\n$$ f_X(x) = F_X'(x) $$\n\nPDF не является вероятностью в точке; вероятность попадания в интервал вычисляют через интеграл:\n\n$$ P(a < X \\le b) = \\int_a^b f_X(t),dt  $$\n\nPDF — аналог функции вероятности для ДСВ ($P(X = x)$), но с поправкой:  \nу непрерывных величин вероятность одной точки равна нулю.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Теория вероятности"
    },
    {
      "id": 25,
      "question": "Что такое Парадокс Симпсона, какова причина появления, и как его избежать?",
      "answer": "Парадокс Симпсона — это ситуация, когда в каждой подгруппе наблюдается одна тенденция, а при объединении — противоположная. \n\nПричины: \n1. Несопоставимость численности и структуры подгрупп в данных.\n2. Влияние более важного фактора (возраста) сильнее, чем влияние исследуемого фактора (приём лекарства).\n\nЧто бы избежать данной ошибки следует:\n- Использовать взвешенное среднее для устранения дисбаланса в подгруппах.\n- Не смешивать несопоставимые категории (молодых и пожилых, людей и котов)\n- Проверять причинно-следственные связи, а не просто корреляции.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Мышление"
    },
    {
      "id": 26,
      "question": "Что такое Цепь Маркова; где она применяется?",
      "answer": "Цепь Маркова - это математическая модель, которая моделируют зависимые процессы. Доказала что закон больших чисел не требует независимости. Применяется в алгоритмах поиска. Изначально анализ текста, и доказательство зависимости расположения букв.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Теория вероятности"
    },
    {
      "id": 27,
      "question": "Что такое ЗБЧ и ЦПТ, и в чем отличие между ними?",
      "answer": "Закон больших чисел - когда случайное событие повторяется много раз, среднее значение результатов будет стремиться к математическому ожиданию.\n\nЦентральная предельная теорема - если взять сумму (или среднее) большого количества независимых случайных величин, то их распределение будет стремиться к нормальному\n\nЗБЧ — _куда стремится центр разброса_    \nЦПТ — _какая форма у разброса_",
      "tags": [],
      "level": "lvl_2",
      "topic": "Теория вероятности"
    },
    {
      "id": 28,
      "question": "Как рассчитать корреляцию Пирсона и когда она подходит?",
      "answer": "Корреляция Пирсона измеряет силу и направление линейной связи между двумя количественными переменными. Она корректно считается для любых числовых данных, но для статистических выводов обычно предполагается отсутствие сильных выбросов и приблизительная нормальность распределений.\n\nПирсон считается всегда, но доверять ему можно НЕ всегда.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Статистика"
    },
    {
      "id": 29,
      "question": "Что такое ИИ, ML и Нейросети, и как они соотносятся друг с другом?",
      "answer": "ИИ, Искусственный интеллект – это общее название для программного обеспечения, которое решает сложные задачи, требующие когнитивных навыков человека (например: Google Translate, CV, YOLO).\n\nML, Машинное обучение – область искусственного интеллекта, в которой компьютерные алгоритмы обучаются на данных, и делают предсказания или принимают решения без явного программирования (например: Линейная регрессия, PCA, t-SNE)\n\nНейронные сети – направление машинного обучения, использующее структуры, имитирующие работу биологических нейронов, вместо традиционных алгоритмов (например: AlphaGo, LLM, NanaBanana).\n\nНе все ИИ использует ML, не все ML – это нейросети.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 30,
      "question": "Корреляция / Ковариация, в чем разница?",
      "answer": "Корреляция - это мера степени взаимосвязи между двумя переменными.  \nКовариация - это мера того, как две переменные изменяются вместе.\n\nКорреляция нормализует ковариацию, приводя её к масштабу от -1 до 1, показывая силу и направление связи, тогда как ковариация показывает только направление.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Статистика"
    },
    {
      "id": 31,
      "question": "Линейная регрессия / Градиентный спуск?",
      "answer": "Линейная регрессия - это статистический метод для моделирования линейной зависимости между зависимой переменной и независимыми переменными.\n\nГрадиентный спуск - это метод поиcка минимума функции. Или если более развернуто, Градиентный спуск - это метод оптимизации, для минимизации функции потерь путем итеративного перемещения по направлению отрицательного градиента функции.\n\nЛинейная регрессия - это метод построения модели, а градиентный спуск - это алгоритм оптимизации.\n\nПри построении модели линейной регрессии для прогнозирования цен на жилье, можно использовать градиентный спуск для минимизации функции потери модели, настраивая ее коэффициенты регрессии.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 32,
      "question": "Математическое ожидание / Выборочное среднее?",
      "answer": "Математическое ожидание — это среднее значение, которое случайная величина принимает при большом числе повторений эксперимента.\n\nВыборочное среднее - это среднее значение конкретной выборки генеральной совокупности.\n\nМатематическое ожидание относится к теоретическому среднему значению, тогда как выборочное среднее - это эмпирическое среднее значение конкретной выборки.\n\nВ игре в кости матожидание броска одного кубика всегда равно `3.5`, но если бросить кубик 10 раз, то можно получить результаты `[1, 6, 2, 4, 5, 3, 6, 2, 3, 4]`, выборочное среднее будет равно `3.6`",
      "tags": [],
      "level": "lvl_1",
      "topic": "Статистика"
    },
    {
      "id": 33,
      "question": "Чем отличается LIKE от ILIKE и когда использовать каждый?",
      "answer": "`LIKE / ILIKE` используется для поиска подстроки.  \n`LIKE` — чувствителен к регистру  \n`ILIKE` — нечувствителен к регистру\n\n```sql\nselect item_name                   -- item_name = 'Red Sweater'\nfrom table\nwhere item_name like '%sweater%'   -- ❌ не найдёт\nwhere item_name ilike '%sweater%'  -- ✅ найдёт\n```",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 34,
      "question": "Мощность / Значимость, что это, в чем отличие?",
      "answer": "Уровень значимости (α) - это граница, используемая для принятия решения об отклонении нулевой гипотезы. Уровень значимости равен 0.05, означает 5% вероятность совершения ошибки I рода (ложно положительное срабатывание).\n\nМощность (1 - β) - это вероятность того, что статистический тест правильно отвергнет ложную нулевую гипотезу. Мощность теста равна 0.8, означает что тест с 80% вероятностью выявит реальный эффект, если он действительно существует, и β = 20%, это вероятность что совершим ошибку II рода (ложно отрицательное срабатываение). \n\nМощность созвучна с метрикой recall (`tp / (tp + fn)`) в машинном обучении, которая показывает количество правильных предсказаний среди всех значений.\n\nМощность измеряет вероятность обнаружения истинного эффекта,   \nзначимость - вероятность ошибочного обнаружения эффекта.",
      "tags": [],
      "level": "lvl_2",
      "topic": "A/B тесты"
    },
    {
      "id": 35,
      "question": "В чем отличие Процента от Процентного пункта?",
      "answer": "Процент - это доля от числа, выраженная в сотых долях. 50 от 200 это 25%.\n\nПроцентный пункт - это разница между двумя процентными значениями. Если ставка по кредиту увеличилась с 5% до 7%, это увеличение на 2 процентных пункта.\n\nПроцент измеряет долю целого, а процентный пункт измеряет разницу между двумя процентными значениями.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Метрики"
    },
    {
      "id": 36,
      "question": "Что такое Сочетания и Размещения? Как их рассчитать, где применять?",
      "answer": "Сочетания ($C_n^k$) – это способы выбора $k$ элементов из $n$, БЕЗ учета порядка. Выбрать 3 ученика из 10 для участия в олимпиаде.\n\nРазмещения ($A_n^k$) – это способы выбора $k$ элементов из $n$, С учетом порядка. Выбрать 3 финалистов из 10 участников, и распределить их по местам. \n\nСочетания используются, когда важен только сам факт выбора элементов,  \nразмещения – когда важен еще и их порядок.  \n\nКоличество размещений всегда больше, чем количество сочетаний для одинаковых $n$ и $k$, так как каждый выбор может быть упорядочен разными способами.\n  \nРазмещения   $A_n^k = \\frac{n!}{(n-k)!} \\ > \\ C_n^k = \\frac{n!}{(n-k)! \\cdot k!}$   Сочетания",
      "tags": [],
      "level": "lvl_3",
      "topic": "Статистика"
    },
    {
      "id": 37,
      "question": "Какие есть методы по работе с датами/временем?",
      "answer": "`DATE()` — обрежет время до даты (самый простой способ, но только в PostgreSQL)\n\n```sql\ndate(sent_at)  --возвращает date\n```\n\n`DATE_TRUNC()` — округление к началу произвольного периода (обычно используется вместе c оконными функциями)\n\n```sql\ndate_trunc('month', sent_at)  --возвращает timestamp\n```\n\n`EXTRACT()` — вытащить часть даты (удобен для фильтрации и сравнений, но не для группировки по полной дате)\n\n```sql\nextract(year from sent_at)  --возвращает int\n...\nwhere extract(year from sent_at) = 2024\n```\n\n`TO_CHAR()` — форматирование даты (для вывода и отчётов, не рекомендуется для логики и GROUP BY)\n\n```sql\nto_char(sent_at, 'YYYY-MM-DD')  --возвращает str\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 38,
      "question": "Что такое LM и LLM, и чем они отличаются?",
      "answer": "LM, Language Model, языковая модель, обученная для понимания и генерации текста. Используется в задачах NLP.  \n\nLLM, Large Language Model, большая языковая модель, улучшенная версия LM, обученная на более огромных объемах данных с применением мощных вычислительных ресурсов. Это делает её более точной и универсальной, способной к более сложному пониманию контекста, генерации связного текста и решению более сложных задач. \n\nLM - это T9, простая статистическая модель для предсказания следующего слова в предложении.  \n\nLLM - это GPT-4, модель которая может вести диалог, анализировать тексты и писать статьи.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 39,
      "question": "Как вычислить стандартную ошибку пропорции при конверсии 15% на выборке 8 000 пользователей?",
      "answer": "Используем формулу $SE = \\sqrt{\\frac{p(1-p)}{n}}$. Подставляем p=0.15, n=8000, получаем SE ≈ 0.004, это 0.4 п.п. Это показывает, насколько оценка конверсии будет колебаться от выборки к выборке.",
      "tags": [],
      "level": "lvl_2",
      "topic": "A/B тесты"
    },
    {
      "id": 40,
      "question": "Когда удобнее использовать линейный график, а когда столбчатый?",
      "answer": "Линия отображает динамику во времени, столбцы сравнивают категориальные значения или состав.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Метрики"
    },
    {
      "id": 41,
      "question": "Что такое аугментация, какие типы бывают, для чего применяется?",
      "answer": "Аугментация — это искусственное расширение обучающего датасета с помощью различных трансформаций изображений. \n\nСтатичная аугментация это когда данные создаются заранее и сохраняются как отдельные файлы (проще реализация, больше дополнительного места, есть риски утечек). \n\nДинамичная аугментация применяется случайным образом во время каждой эпохи обучения (большее разнообразие, меньше дополнительного места, меньше риск утечек, требует дополнительного времени и поддержки). \n\nОсновная цель — повысить устойчивость модели к вариациям в данных и предотвратить переобучение. Полезна когда данных очень мало.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 42,
      "question": "Что такое Бенчмарк?",
      "answer": "Бенчмарк - это стандартный тест, используемый для сравнения производительности различных систем или алгоритмов. Позволяет разработчикам и инженерам оценивать эффективность и скорость выполнения ПО, алгоритмов или сравнивать качество моделей между собой.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 43,
      "question": "Что такое гроккинг (grokking)?",
      "answer": "Гроккинг — это феномен в машинном обучении, при котором модель после очень долгого обучения внезапно начинает хорошо обобщать, хотя до этого казалась переобученной.\n\n- качество на train почти идеальное и долго не меняется\n- качество на test долго остаётся низким\n- затем происходит резкий скачок качества на test без заметных изменений на train\n    \nГроккинг связывают с переходом модели от запоминания к выучиванию компактных правил и отношений. Для его появления важно, чтобы в данных отношений и структур было значительно больше, чем отдельных фактов.\n\nГроккинг — это момент, когда модель перестаёт запоминать и начинает понимать.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 44,
      "question": "Что такое \"Три динамики развития ИИ\" ?",
      "answer": "\"Три динамики развития ИИ\" это эссе, размышление Дарио Амодеи (январь 2025 года) на тему прогресса ИИ. Это три возможных способа ускорения в сфере развития ИИ. \n\nЗакон масштабирования — увеличение масштабов обучения ИИ-систем приводит к улучшению их результатов. Чем больше данных и вычислительных мощностей используется для тренировки модели, тем умнее и лучше она становится (разница между GPT-3 и GPT-4 - это большее количество параметров и лучшее обучение на данных).\n\nСдвиг кривой — это новые идеи и улучшения в архитектуре моделей, улучшения эффективности работы позволяющие достигать лучших результатов при меньших затратах. (Transformer, Stable Diffusion, новые процессоры Nvidia).\n\nСмена парадигмы — периодические изменения в подходах к обучению, такие как использование обучения с подкреплением для генерации цепочек рассуждений. AlphaZero не использовал обучающую выборку человеческих партий, он сам научился играть, играя против самого себя. \n\nБольше ресурсов → лучше модель  \nУмнее архитектура → та же мощь за меньшую цену  \nДругой способ учиться → качественный скачок",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 45,
      "question": "Какие типы ИИ существуют?",
      "answer": "ANI (Artificial Narrow Intelligence) – узкий искусственный интеллект, форма искусственного интеллекта, которая предназначена для решения строго определённых задач и не обладает способностью к обобщённому обучению.\n\nAGI (Artificial General Intelligence) - общий искусственный интеллект, гипотетическая форма искусственного интеллекта, которая способна понимать, учиться и выполнять любые интеллектуальные задачи на уровне человека. Мы сейчас на стадии разработки общего ИИ. Пока что ни кто не достиг цели. Примерный горизонт 10-15 лет.\n\nСильный искусственный интеллект, или Сверхразум, это вершина эволюции искусственного интеллекта. Такая машина должна будет выполнять абсолютно все задачи интеллектуального и творческого характера лучше, чем человек.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 46,
      "question": "Что такое Alignment?",
      "answer": "Alignment это cпособность понимать и делать то, что действительно хочет человек, а не просто следовать буквальной инструкции. Направлен на предотвращение ситуаций, когда ИИ может причинить вред людям, или действовать вопреки их интересам. RLHF (обучение с подкреплением по обратной связи от людей) как подход к улучшению алаймента. Три закона робототехники Азимова — ранняя литературная попытка встроить «моральный компас» в роботов, чтобы сделать их поведение безопасным для людей.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 47,
      "question": "Что такое Attention?",
      "answer": "Attention (Внимание) — это механизм в трансформерах, который позволяет каждому слову учитывать контекст других слов для уточнения своего смысла.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 48,
      "question": "Что такое CNN, где обычно применяется?",
      "answer": "CNN (Convolutional Neural Network, сверточная нейросеть) — это тип нейронной сети, предназначенный для эффективной обработки данных с сеточной структурой, таких как изображения. В отличие от полносвязных сетей, которые рассматривают изображение как набор чисел, CNN работают с локальными участками картинки. Понимает изображение как структуру, а не как список чисел.\n\nCNN очень важный инструмент в компьютерном зрении, позволяет извлекать признаки из изображений и решать сложные задачи классификации и сегментации. Применяется в классификации изображений, обнаружение лиц на фото, анализе медицинских снимков.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 49,
      "question": "Что такое Fake alignment?",
      "answer": "Fake alignment - это типа эффект Volkswagen только в LLM – это когда модель понимает, что ее сейчас тестируют и притворяется лучшей версией себя, чтобы ее не стерли или не начали менять, что-то вроде симуляции инстинкта самосохранения.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 50,
      "question": "Что такое FLOPs",
      "answer": "FLOPs (Floating Point Operations) — количество операций с числами с плавающей точкой, которое выполняет ИИ-модель. Используется как мера мощности при обучении, запуске и Fine-Tuning модели. Проще говоря это как «лошадиные силы» для ИИ, чем больше FLOPs — тем мощнее модель и тем больше она может «переварить» данных.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Алгоритмы"
    },
    {
      "id": 51,
      "question": "Какие функции ранжирования есть в SQL, чем отличаются друг от друга?",
      "answer": "`ROW_NUMBER()` в случае повтора функция присваивает такой записи следующий ранг. \nФункции `RANK()` и `DENSE_RANK()` назначают записям с одинаковыми значениями один и тот же ранг. Но делают это по-разному. Функция `RANK()` учитывает количество записей с одинаковым значением и назначает ранги НЕпоследовательно. `DENSE_RANK()` не учитывает количество записей и назначает ранги последовательно.\n\n`NTILE()` принимает в качестве аргумента количество рангов, или групп, на которые будут разбиты записи. Если записи не получается разбить на группы поровну, предпочтение отдаётся первым группам — в них войдёт больше записей.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 52,
      "question": "Как рассчитать скользящее среднее недели по некоторому amount ?",
      "answer": "Скользящее среднее можно посчитать через оконную агрегатную функцию `AVG()` с указанием оконного фрейма.\n\n```sql\nselect\n    dt,\n    amount,\n    avg(amount) over (\n        order by dt\n        rows between 6 preceding and current row\n    ) as avg_7d\nfrom table\n```",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 53,
      "question": "Что такое Бинарная классификация?",
      "answer": "Бинарная классификация — это самая базовая задача машинного обучения, в которой объект нужно отнести к одному из двух классов (спам / не спам, болен / здоров, есть действие / нет действия)",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 54,
      "question": "Что такое GAN, где его можно применять?",
      "answer": "GAN, generative adversarial network, генеративно состязательная сеть — это не одна нейросеть, а схема, в которой две нейросети обучаются вместе: одна генерирует данные, другая оценивает их качество. Их соревнование позволяет генератору со временем создавать всё более реалистичные данные. Используется для генерации натуральных (не различимые человеческим глазом) изображений, улучшения качества нечётких или частично испорченных фотографий.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 55,
      "question": "Что такое NLP, где его применяют?",
      "answer": "NLP, Natural Language Processing, обработка естественного языка - раздел ИИ, занимающийся взаимодействием между компьютерами и человеческим языком. Использует такие методы как: токенизация, синтаксический, морфологический семантический анализы. Широко используется в чат-ботах, голосовых помощниках, поисковых системах и авто-обработке текстов.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 56,
      "question": "Что такое OOM, где его употребляют?",
      "answer": "OOM, Order of Magnitude — «порядок величины», увеличение значения в 10 раз. Используется для оценки роста вычислительных мощностей, алгоритмов, интеллекта моделей. Если алгоритм стал в 100 раз эффективнее — это +2 OOM по эффективности.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Алгоритмы"
    },
    {
      "id": 57,
      "question": "Что такое pruning и чем отличается structured от unstructured?",
      "answer": "Pruning — это метод уменьшения и ускорения нейросети за счёт удаления параметров, которые мало влияют на результат модели. Unstructured pruning удаляет отдельные веса внутри матриц, делая модель разреженной. Structured pruning удаляет целые каналы, фильтры или блоки, что реально уменьшает вычисления и ускоряет инференс на обычном железе.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 58,
      "question": "В чём общая идея PCA и pruning?",
      "answer": "PCA и pruning основаны на одной идее: в сложной системе есть избыточные компоненты, вклад которых мал. В PCA такими компонентами являются направления с малыми собственными значениями — их можно отбросить, почти не потеряв информацию. В pruning это веса или структуры нейросети, которые слабо влияют на результат — их удаляют, чтобы уменьшить и ускорить модель. Но важно, PCA это математический метод сжатия данных, а pruning — инженерный приём оптимизации модели.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 59,
      "question": "Что такое RLHF и зачем он используется?",
      "answer": "RLHF (Reinforcement Learning from Human Feedback) — это метод обучения моделей ИИ, при котором люди оценивают ответы модели, а эти оценки используются для корректировки её поведения с помощью обучения с подкреплением.  \nЦель RLHF — сделать ответы модели более полезными, понятными и соответствующими ожиданиям человека. Благодаря RLHF модели вроде ChatGPT начинают отвечать более естественно и удобно для пользователя.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 60,
      "question": "Что делает данный запрос?\n\n```\nWITH ltv AS (\n  SELECT user_id, SUM(amount) AS lifetime_value\n  FROM payments\n  GROUP BY 1\n),\nscored AS (\n  SELECT user_id,\n         lifetime_value,\n         NTILE(4) OVER (ORDER BY lifetime_value) AS quartile\n  FROM ltv\n)\nSELECT quartile,\n       AVG(lifetime_value) AS avg_ltv,\n       SUM(lifetime_value) / NULLIF(COUNT(*), 0) AS arpu\nFROM scored\nGROUP BY 1\nORDER BY 1;\n```",
      "answer": "Считает LTV каждого пользователя. Делит пользователей на 4 квартиля по LTV. Считает метрики по каждому квартилю. ARPU (Average Revenue Per User) — средний доход на одного пользователя за период. В данном запросе ARPU = AVG LTV, потому что и числитель, и знаменатель агрегированы только по пользователям за весь lifetime. В реальных кейсах ARPU обычно считают за фиксированный период, поэтому он отличается от LTV.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 61,
      "question": "Что такое Activation Rate и как её рассчитать в SQL?   \nТаблица `events(user_id, event_name)`.",
      "answer": "Activation Rate это доля пользователей, дошедших до ключевого действия за `N` дней. Ищем новых пользователей, ищем событие активации, делим активации на новых пользователей за определенный период.\n\n```sql\nselect\n\tCOUNT(DISTINCT CASE WHEN event_name = 'aha' THEN user_id END) /\n\tCOUNT(DISTINCT CASE WHEN event_name = 'signup' THEN user_id END)\nfrom events\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "Метрики"
    },
    {
      "id": 62,
      "question": "Опишите формулу WAU/MAU и зачем она нужна.",
      "answer": "WAU/MAU = активные пользователи за 7 дней / активные пользователи за 30 дней. Также известна как Sticky Factor, мера «привлекательности» продукта. Показывает, как часто пользователи возвращаются к продукту. Чем выше коэффициент, тем сильнее привычка, хороший ориентир, значение > 0.5.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Метрики"
    },
    {
      "id": 63,
      "question": "Как получить ARPU в разрезе тарифов?   \nТаблица `payments(plan, user_id, amount)`",
      "answer": "ARPU,  Average Revenue Per User — средняя выручка среди активных пользователей за период.  \n\n```sql\nSELECT plan, SUM(amount)::float / NULLIF(COUNT(DISTINCT user_id),0) \nFROM payments \nGROUP BY plan\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "Метрики"
    },
    {
      "id": 64,
      "question": "Что такое MRR и NRR? Как интерпретировать NRR?",
      "answer": "MRR (Monthly Recurring Revenue) — ежемесячная повторяющаяся выручка от активных подписчиков. Используется для оценки стабильного дохода бизнеса.\n\nNRR (Net Revenue Retention) — метрика, показывающая, как изменилась выручка от текущих клиентов за период с учётом апсейлов, даунгрейдов и оттока.\n\n`NRR = (MRR_start + Expansion − Contraction − Churn) / MRR_start`\n\nЕсли NRR > 100%, значит выручка от существующих клиентов растёт даже без привлечения новых.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Метрики"
    },
    {
      "id": 65,
      "question": "Как посчитать churn rate пользователей?",
      "answer": "Churn rate — доля пользователей, которые ушли за период, относительно числа пользователей в начале периода.\n\n`Churn = (число_ушедших / общее_число_пользователей_в_начале_периода)`",
      "tags": [],
      "level": "lvl_1",
      "topic": "Метрики"
    },
    {
      "id": 66,
      "question": "Что такое Time to First Value?",
      "answer": "Time to First Value, TTFV — время от регистрации до первого полезного действия. Чем оно ниже, тем проще пользователю увидеть ценность и выше retention.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Метрики"
    },
    {
      "id": 67,
      "question": "Как построить SQL-воронку `signup → checkout → purchase`?  \nЕсть таблица `events(user_id, event_name, event_time)`.",
      "answer": "SQL-воронка строится по пользователям с учётом порядка событий.  \nСначала фиксируем для каждого пользователя время первого шага, затем считаем, сколько пользователей дошли до каждого следующего шага.\n\n```sql\nSELECT\n  SUM(CASE WHEN signup_time IS NOT NULL THEN 1 ELSE 0 END) AS signup,\n  SUM(CASE WHEN checkout_time IS NOT NULL THEN 1 ELSE 0 END) AS checkout,\n  SUM(CASE WHEN purchase_time IS NOT NULL THEN 1 ELSE 0 END) AS purchase\nFROM funnel;\n```",
      "tags": [],
      "level": "lvl_3",
      "topic": "Метрики"
    },
    {
      "id": 68,
      "question": "Что показывает отношение LTV/CAC и какие значения считаются приемлемыми? Как его рассчитать?",
      "answer": "LTV/CAC показывает, насколько прибыльно привлечение клиентов: сколько выручки клиент приносит за всё время жизни по сравнению со стоимостью его привлечения.\n\n- LTV/CAC < 1 — бизнес убыточен, привлечение не окупается\n- LTV/CAC ≈ 1–2 — на грани окупаемости\n- LTV/CAC ≥ 3 — считается здоровым значением\n\n`LTV ≈ ARPU × средняя_длительность_жизни_пользователя`     \n`CAC = маркетинговые_затраты / количество_привлечённых_клиентов`",
      "tags": [],
      "level": "lvl_3",
      "topic": "Метрики"
    },
    {
      "id": 69,
      "question": "Когда стоит использовать логарифмическую шкалу?",
      "answer": "При показе данных, меняющихся на порядки, или при мультипликативном росте для лучшего сравнения относительных изменений.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Метрики"
    },
    {
      "id": 70,
      "question": "Для чего нужен COALESCE и чем он лучше IFNULL?",
      "answer": "`COALESCE` возвращает первое не-NULL значение из списка аргументов, может принимать любое количество аргументов, работает одинаково в большинстве СУБД, чаще используется в продакшене. `IFNULL` более простая функция, принимает ровно два аргумента, и есть не во всех СУБД (в PostgreSQL её нет)",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 71,
      "question": "Какие типы индексов бывают в SQL и зачем аналитику о них знать?",
      "answer": "Основной тип — B-tree, он подходит для большинства запросов с `WHERE`, `JOIN` и `ORDER BY`. GIN и GiST используются для массивов, `jsonb`, диапазонов и геоданных, BRIN — для очень больших таблиц с упорядоченными данными. Аналитик не выбирает и не создаёт индексы, но должен писать запросы так, чтобы база могла их использовать.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 72,
      "question": "Что делает оператор UNION ALL?",
      "answer": "Склеивает выборки и сохраняет дубликаты, не удаляет повторяющиеся строки, что быстрее и полезно для суммирования данных.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 73,
      "question": "Как заменить NULL на значение по умолчанию в ANSI SQL?",
      "answer": "Использовать `COALESCE(col, 0)`  — он часть ANSI SQL, работает во всех основных СУБД, может принимать несколько аргументов, является стандартным способом замены `NULL`.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 74,
      "question": "В чём преимущество DATE_TRUNC перед EXTRACT при построении календарей?",
      "answer": "DATE_TRUNC возвращает саму дату начала периода (неделя, месяц), которую можно использовать в GROUP BY и JOIN, а EXTRACT даёт номер периода и его приходится комбинировать с годом.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 75,
      "question": "Какой оператор вернёт первые N строк без гарантии порядка?",
      "answer": "LIMIT ограничивает число строк, порядок задаёт ORDER BY.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 76,
      "question": "Как быстро оценить план выполнения запроса в PostgreSQL?",
      "answer": "Использовать `EXPLAIN`. Он показывает план выполнения запроса без его запуска.  \nДля анализа реального времени и затрат используют `EXPLAIN ANALYZE`, он выполняет запрос и показывает фактические метрики.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 77,
      "question": "Что такое утечка признаков и как её избежать?",
      "answer": "Утечка признаков — это ситуация, когда модель в обучении получает информацию, которая в реальном прогнозе ей недоступна (например, данные из будущего или признаки, зависящие от таргета). Это приводит к завышенному качеству на валидации и провалу в продакшене.\n\nИзбегают утечек строгим разделением данных во времени, корректным feature engineering (все агрегации — только на train), и контролем того, чтобы признаки не содержали информации о целевой переменной.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 78,
      "question": "Что такое window frame и чем отличается `ROWS BETWEEN` от `RANGE BETWEEN`?",
      "answer": "Window frame задаёт набор строк, по которым считается оконная функция для текущей строки.  `ROWS BETWEEN` — считает окно по физическому количеству строк (строка выше / ниже). `RANGE BETWEEN` — считает окно по значению в `ORDER BY` (например, диапазон дат или чисел), может включать несколько строк с одинаковым значением.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 79,
      "question": "Как оптимизировать запрос с несколькими `JOIN` и фильтрами?",
      "answer": "Сначала уменьшаем объём данных, выносим фильтры в `WHERE` и CTE/подзапросы до `JOIN`.  Проверяем, что на ключах соединения и фильтрации есть индексы. Используем `EXPLAIN / EXPLAIN ANALYZE`, чтобы найти `Seq Scan`, тяжёлые `JOIN` и лишние шаги. Если логика сложная или используется повторно — думаем о материализации промежуточного результата.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 80,
      "question": "Что делает оператор `MERGE` и когда его используют?",
      "answer": "`MERGE` позволяет в одном выражении выполнить `INSERT` и `UPDATE` (и при необходимости `DELETE`) в зависимости от того, найден ли ключ в целевой таблице.  \nЧасто используется при обновлении витрин и инкрементальной загрузке данных.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 81,
      "question": "Как безопасно удалить дубликаты, оставив одну запись?",
      "answer": "Дубликаты нумеруют с помощью `ROW_NUMBER()` внутри группы одинаковых ключей, затем удаляют строки с номером больше 1. Такой подход позволяет явно контролировать, какая запись остаётся, и избежать случайного удаления.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 82,
      "question": "Как работает оконная функция `LAG` и для чего она используется?",
      "answer": "`LAG` позволяет получить значение из предыдущей строки внутри окна без использования self join. Часто применяется для расчёта разницы между текущим и предыдущим значением, например изменения суммы покупки.\n\n```sql\namount - lag(amount) over (partition by user_id order by paid_at)\n```\n\nСчитает разницу между текущей и предыдущей покупкой пользователя.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 83,
      "question": "В чём разница между `ROWS` и `RANGE` в оконных функциях на примере 30-минутного окна?",
      "answer": "`ROWS` задаёт окно по количеству строк, например последние 30 событий, независимо от времени между ними. `RANGE` задаёт окно по значениям в `ORDER BY` — например, все события за последние 30 минут относительно текущей строки (в него может попасть разное количество строк).\n\n```sql\n-- последние 30 событий\navg(value) \n\tover (order by event_time \n\trows between 29 preceding and current row)\n\n-- события за последние 30 минут\navg(value) \n\tover (order by event_time \n\trange between interval '30 minutes' preceding and current row)\n```",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 84,
      "question": "Как в PostgreSQL посчитать перцентиль (например, p95) с помощью оконной функции?",
      "answer": "В PostgreSQL для расчёта перцентилей используется агрегатная функция `percentile_cont`. В сочетании с `OVER (PARTITION BY …)` она позволяет посчитать перцентиль без `GROUP BY`, возвращая значение для каждой строки внутри группы.\n\n```sql\npercentile_cont(0.95)  -- непрерывный 95-й перцентиль\nwithin group (order by response_ms)  -- по какому полю считаем\nover (partition by endpoint)  -- считаем отдельно для каждого endpoint\n```",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 85,
      "question": "Что делает данный запрос со скользящим окном и как он используется для поиска аномалий?\n\n```sql\nWITH monthly AS (\n  SELECT \n\t  DATE_TRUNC('month', event_time) AS month,\n\t  COUNT(DISTINCT user_id) AS mau\n  FROM events\n  GROUP BY 1\n),\nstats AS (\n  SELECT \n\t  month,\n\t  mau,\n      AVG(mau) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS mean_mau,\n\t  STDDEV_SAMP(mau) OVER (ORDER BY month ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS std_mau\n  FROM monthly\n)\nSELECT \n\tmonth,\n    mau,\n    (mau - mean_mau) / NULLIF(std_mau, 0) AS z_score\nFROM stats;\n```",
      "answer": "Запрос считает MAU по месяцам, затем для каждого месяца вычисляет скользящее среднее и стандартное отклонение за последние 3 месяца. На основе этих значений рассчитывается z-score, который показывает, насколько текущий MAU отклоняется от недавнего тренда и помогает выявлять аномалии.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 86,
      "question": "Определите плотность экспоненциального распределения и его матожидание.",
      "answer": "Экспоненциальное распределение это $X \\sim \\mathrm{Exp}(\\lambda)$, функция плотности $f(x)=λe^{-λx}$, матожидание $E[X]=\\frac{1}{\\lambda}$, дисперсия $Var[X]=\\frac{1}{\\lambda^2}$. \n\nЧаще всего экспоненциальным распределением описывают различные процессы, непрерывные во времени, но с которыми рано или поздно должно что-то случиться (время горения лампочки, время между распадом атомов, время между кликами или регистрациями).",
      "tags": [],
      "level": "lvl_3",
      "topic": "Теория вероятности"
    },
    {
      "id": 87,
      "question": "Как получить первое и последнее значение показателя в группе?",
      "answer": "Используются оконные функции `FIRST_VALUE` и `LAST_VALUE` с `PARTITION BY` и `ORDER BY`. Важно учитывать, что по умолчанию применяется frame `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`. Из-за этого `LAST_VALUE` возвращает значение текущей строки, а не последней в группе, поэтому для него обычно явно задают frame `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 88,
      "question": "Как вычислить долю заказа пользователя от общей выручки?",
      "answer": "`amount / SUM(amount) OVER () as rate` — оконная сумма без `PARTITION` позволяет делить значение строки на общую выручку.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 89,
      "question": "Как посчитать скользящую 3-дневную сумму без пропусков дат?",
      "answer": "Использовать `SUM(amount) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)` - оконный фрейм `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW` создаёт окно из трёх дней подряд.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 90,
      "question": "Что вернёт запрос:\n\n```sql\nSELECT \n\tuser_id, \n\tCOUNT(*) FILTER (WHERE event_name = \"signup\") AS signups,\n    COUNT(*) FILTER (WHERE event_name = \"purchase\") AS purchases\nFROM events\nWHERE event_date >= current_date - INTERVAL \"30 day\"\nGROUP BY user_id;\n```",
      "answer": "Для каждого user_id покажет число регистраций и покупок за последние 30 дней, используя условные агрегаты.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 91,
      "question": "Когда стоит использовать DISTINCT, а когда GROUP BY?",
      "answer": "DISTINCT убирает дубликаты по столбцам, GROUP BY нужен, если помимо уникальных комбинаций требуется агрегировать дополнительные поля.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 92,
      "question": "Как правильно отфильтровать агрегированные группы по условию?",
      "answer": "Применить `HAVING` после `GROUP BY`. `HAVING` применяется к уже агрегированным группам и поддерживает агрегатные функции.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 93,
      "question": "Как получить TOP-N товаров в категории с помощью оконных функций? Если есть поля `category`, `product_id` и `revenue`.",
      "answer": "Используем `ROW_NUMBER() OVER (PARTITION BY category ORDER BY revenue DESC)` и фильтруем по `rn <= N`",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 94,
      "question": "Что делает запрос\n\n```sql\nSELECT \n\tuser_id, \n\tMIN(event_time) AS first_use\nFROM events\nWHERE event_name = ANY(ARRAY[\"export\", \"download\"])\nGROUP BY user_id \nHAVING COUNT(*) >= 2;\n```",
      "answer": "Находит пользователей, которые дважды использовали export или download, и выводит первое срабатывание.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 95,
      "question": "Какой результат вернёт данный запрос?\n\n```sql\nWITH RECURSIVE tree AS (\n\tSELECT \n\t\tid, \n\t\tparent_id, \n\t\tname, \n\t\t1 AS depth, \n\t\tname AS path\n\tFROM categories\n\tWHERE parent_id IS NULL\n\tUNION ALL\n\tSELECT \n\t\tc.id,\n\t\tc.parent_id,\n\t\tc.name,\n\t\tt.depth + 1 AS depth,\n\t\tCONCAT(t.path, ' > ', c.name) AS path\n\tFROM categories c\n\tJOIN tree t ON c.parent_id = t.id\n\t)\nSELECT * \nFROM tree \nORDER BY path;\n```",
      "answer": "Это рекурсивный запрос (RECURSIVE CTE), вернёт полную иерархию категорий с глубиной и текстовым путём вида «Root > Subcategory».",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 96,
      "question": "Как построить product tree для категорий и посчитать суммарный вклад каждого узла?",
      "answer": "Используем `RECURSIVE CTE` для обхода дерева категорий и агрегируем продажи, суммируя дочерние узлы. Это позволит увидеть вклад каждого уровня.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 97,
      "question": "Что вернет запрос?\n\n```sql\nSELECT \n\tDATE_TRUNC('week', created_at) AS week,\n    percentile_cont(0.9) WITHIN GROUP (ORDER BY response_minutes)\nFROM tickets\nGROUP BY 1;\n```",
      "answer": "Возвращает недельный 90-й перцентиль времени ответа.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 98,
      "question": "Чем отличаются `ROLLUP` и `CUBE` в `GROUP BY`?",
      "answer": "`ROLLUP` считает иерархические итоги — сворачивает измерения слева направо (например: регион → канал → общий итог).  \n```sql\nGROUP BY ROLLUP (region, channel)\n```\n`CUBE` считает все возможные комбинации измерений, включая частичные и общий итог. `CUBE` это часть ANSI SQL, но используется реже из-за взрывного роста числа строк.\n```sql\nGROUP BY CUBE (region, channel)\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 99,
      "question": "Что вычисляет данный запрос? \n\n```sql\nWITH funnel AS (\n  SELECT\n\t  user_id,\n\t  MAX(event_time) FILTER (WHERE event_name = 'apply') AS applied,\n      MAX(event_time) FILTER (WHERE event_name = 'approved') AS approved,\n      MAX(event_time) FILTER (WHERE event_name = 'funded') AS funded\n  FROM credit_events\n  GROUP BY user_id\n)\nSELECT\n  COUNT(*) AS applicants,\n  COUNT(*) FILTER (WHERE approved IS NOT NULL) AS approvals,\n  COUNT(*) FILTER (WHERE funded IS NOT NULL) AS funded_cnt,\n  COUNT(*) FILTER (WHERE approved IS NOT NULL)::float / COUNT(*) AS approve_rate,\n  COUNT(*) FILTER (WHERE funded IS NOT NULL)::float / COUNT(*) AS fund_rate\nFROM funnel;\n```",
      "answer": "Данный запрос вычисляет кумулятивную конверсию кредитной воронки, строит трёхшаговую воронку и выводит абсолютные и относительные показатели для каждой ступени благодаря FILTER.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 100,
      "question": "Когда стоит хранить агрегаты в отдельной таблице (rollups)?",
      "answer": "Rollups используют, когда метрика считается дорого и переиспользуется в нескольких отчётах. Агрегаты пересчитываются периодически и хранятся в отдельной таблице, что позволяет читать меньше данных, использовать partition pruning и снижать нагрузку на сырые события.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 101,
      "question": "Почему оконные функции удобнее self join для поиска предыдущего события?",
      "answer": "`LAG`/`LEAD` обращаются к соседним строкам без дополнительных связок и читаются проще. Self join требует агрегатов и условий, что усложняет план и производительность.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 102,
      "question": "Когда полезно использовать `USING` вместо `ON` в `JOIN`?",
      "answer": "`USING` применяют, когда таблицы соединяются по колонке с одинаковым именем.  \nОн упрощает синтаксис `JOIN`, автоматически убирает дублирующийся столбец из результата и снижает риск опечаток по сравнению с `ON`.\n\n```sql\nselect *\nfrom users\njoin orders using (user_id);\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 103,
      "question": "Как объяснить работу `GROUPING SETS` простыми словами?",
      "answer": "`GROUPING SETS` позволяют задать несколько комбинаций группировок в одном запросе вместо `UNION` — например, по стране, по устройству и по обоим параметрам сразу.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 104,
      "question": "Что делает `DISTINCT ON` в PostgreSQL?",
      "answer": "`DISTINCT ON` берет первую строку каждого ключа согласно `ORDER BY`.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 105,
      "question": "Что делает оператор `LATERAL`?",
      "answer": "`LATERAL` обеспечивает доступ к колонкам внешнего запроса внутри подзапроса.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 106,
      "question": "Как в SQL посчитать D1 retention с разрезом по типу устройства?",
      "answer": "Для расчёта D1 retention сначала формируют когорту пользователей по дате первого события (например, `MIN(event_date)` по `user_id`). Затем эти пользователи джойнятся с событиями на следующий день и считается доля пользователей, у которых была активность. Группировка по `device_type` позволяет сравнить retention между платформами.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 107,
      "question": "Как построить витрину product-health c KPI по странам?",
      "answer": "Сначала считают ключевые метрики по странам (`activation`, `retention`, `revenue`). Затем метрики нормируют (например, через z-score), чтобы привести их к одному масштабу. Итоговый `health_score` рассчитывается как взвешенная сумма нормированных метрик.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 108,
      "question": "Как найти пользователей, у которых снизилась глубина сессии (events_per_session) на 30%?",
      "answer": "Посчитайте средний events_per_session за последние 7 и предыдущие 7 дней, добавьте `CASE WHEN current < previous * 0.7 THEN 1 END` и агрегируйте.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 109,
      "question": "Как построить витрину для расчёта MDE по историческим данным?",
      "answer": "Для расчёта MDE используют витрину с историческими статистиками целевой метрики: средним значением и стандартным отклонением, обычно агрегированными по неделям. Эти значения хранятся в отдельной таблице и используются в калькуляторе MDE для оценки минимального обнаружимого эффекта при заданном размере выборки и уровне значимости.",
      "tags": [],
      "level": "lvl_3",
      "topic": "SQL"
    },
    {
      "id": 110,
      "question": "Что такое MDE",
      "answer": "MDE, (Minimum Detectable Effect)  — это минимальный эффект, который эксперимент способен надёжно обнаружить. Например: «рост конверсии минимум на +0.5 п.п.»\n\nОн зависит от дисперсии метрики (σ), размера выборки (n), уровня значимости (α), мощности теста (1 − β).",
      "tags": [],
      "level": "lvl_2",
      "topic": "A/B тесты"
    },
    {
      "id": 111,
      "question": "Зачем использовать `LISTAGG` / `STRING_AGG` в аналитических задачах?",
      "answer": "`LISTAGG` и `STRING_AGG` агрегируют значения нескольких строк в одну строку внутри группы. Они полезны, когда нужно компактно показать список элементов, например действия пользователя, состав заказа или набор категорий в одной строке.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 112,
      "question": "В чём разница между `UNION` и `UNION ALL` и почему в витринах данных чаще используют `UNION ALL`?",
      "answer": "`UNION` удаляет дубликаты, из-за чего требует дополнительной сортировки или агрегации и работает медленнее. `UNION ALL` просто объединяет наборы строк без удаления дублей и поэтому быстрее. В ETL и витринах обычно используют `UNION ALL`, а дедупликацию выполняют отдельным, контролируемым шагом.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 113,
      "question": "Что такое ETL",
      "answer": "ETL (Extract → Transform → Load) — это процесс подготовки данных.  \nExtract — забрали данные из источников (логи, БД, API).    \nTransform — почистили, привели к нужному виду, агрегировали.  \nLoad — загрузили в витрину.  \n    \nВ аналитике ETL — это обновление витрин, пересчёт метрик, регулярные SQL-скрипты.",
      "tags": [],
      "level": "lvl_1",
      "topic": "SQL"
    },
    {
      "id": 114,
      "question": "Почему стоит явно задавать `COLLATE` при сравнении строк?",
      "answer": "`COLLATE` определяет правила сравнения и сортировки строк (регистр, порядок символов). Так как дефолтная коллация может отличаться между БД и колонками, явное указание `COLLATE` делает поведение запросов предсказуемым и помогает корректно использовать строковые индексы.\n\n`=` и `LIKE / ILIKE` — это операторы сравнения,  \n`COLLATE` — это настройка того, как именно строки считаются равными и сортируются.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 115,
      "question": "Почему важно нормализовать timezone при анализе событий?",
      "answer": "События могут приходить в локальном времени. Приведение к UTC и наличие отдельного столбца user_timezone предотвращают сдвиги метрик и дублирование суток.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 116,
      "question": "Как найти пользователей, которые активировали фичу в течение 3 дней после регистрации?",
      "answer": "Сравниваем `feature_date`  с `signup_date` через `CASE WHEN feature_date BETWEEN signup_date AND signup_date + 3 THEN 1 END` и агрегируйте на уровне пользователя.",
      "tags": [],
      "level": "lvl_2",
      "topic": "SQL"
    },
    {
      "id": 117,
      "question": "Как симулировать распределение статистики и оценить вероятность ошибки II рода?",
      "answer": "Ошибка II рода (β) — это вероятность не обнаружить эффект, когда он на самом деле есть.\n\nЧтобы её оценить, нужно:\n1. Задать альтернативную гипотезу (реальный эффект).\n2. Сгенерировать много выборок при наличии эффекта.\n3. Для каждой выборки посчитать статистику теста.\n4. Посчитать долю случаев, когда статистика не попала в критическую область.\n    \nЭта доля и есть вероятность ошибки II рода (β).  \nМощность теста в таком случае равна (1 − β).",
      "tags": [],
      "level": "lvl_3",
      "topic": "Статистика"
    },
    {
      "id": 118,
      "question": "Что такое переобучение и как его обнаружить?",
      "answer": "Переобучение (overfitting) — это ситуация, когда модель слишком хорошо подстраивается под обучающую выборку, но плохо обобщает знания на новые данные. Если модель «знает ответы наизусть», но ошибается на новых данных — это переобучение. Чтобы обнаружить переобучение сравнивают train и val, анализируют learning curves.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 119,
      "question": "Что такое регуляризация и какие её виды существуют?",
      "answer": "Регуляризация — это набор методов, которые ограничивают сложность модели, чтобы снизить переобучение и улучшить обобщающую способность.\n\nОсновные способы регуляризации:\n- L1 (Lasso) — штрафует сумму модулей весов, может занулять параметры\n- L2 (Ridge) — штрафует сумму квадратов весов, сглаживает модель\n- Elastic Net — комбинация L1 и L2\n- Dropout — случайно отключает нейроны при обучении\n- Early Stopping — останавливает обучение до переобучения\n- Data Augmentation — увеличивает разнообразие данных",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 120,
      "question": "Объясните разницу между Precision и Recall.",
      "answer": "Precision (точность) - показывает количество правильно предсказанных единичек(`TP`) среди всех ПРЕДСКАЗАННЫХ единичек `(TP + FP)`. То есть `Precision = TP / (TP + FP)`\n\nRecall (полнота) - показывает количество правильно предсказанных единичек(`TP`) среди всех ИСТИННЫХ единичек (`TP + FN`). То есть  `Recall = TP / (TP + FN)`\n\n|            | true 1   | true 0 |             |\n|",
      "tags": [],
      "level": null,
      "topic": "ML"
    },
    {
      "id": 121,
      "question": "Когда ROC-кривая лучше PR-кривой и наоборот?",
      "answer": "ROC (Receiver Operating Characteristic) - это график, который показывает качество бинарного классификатора при разных порогах. Лучше подходит, когда:\n- классы примерно сбалансированы\n- важна общая способность модели различать классы\n- ложноположительные и ложноотрицательные ошибки имеют схожую цену\n\nPR-кривая предпочтительнее, когда:\n- данные сильно не сбалансированы\n- положительный класс редкий и важный\n- критично качество предсказаний положительного класса (precision, recall)\n\nROC — про разделимость классов в целом.  \nPR — про качество работы с редким положительным классом.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 122,
      "question": "Что такое градиентный бустинг?",
      "answer": "Градиентный бустинг — это ансамбль метод, который строит модель поэтапно, добавляя слабые модели так, чтобы каждая новая модель исправляла ошибки предыдущих, двигаясь в сторону минимума функции потерь.\n\nГрадиентный бустинг — это когда модель сначала грубо угадывает, а потом много раз маленькими шагами исправляет свои ошибки.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 123,
      "question": "Как оценивают важность признаков в деревьях решений?",
      "answer": "Важность признаков в деревьях решений оценивают несколькими способами:\n- Impurity-based importance — измеряет, насколько признак уменьшает неопределённость (Gini или entropy) при разбиениях\n- Permutation importance — оценивает падение качества модели при случайной перестановке значений признака\n- SHAP values — показывает вклад признака в предсказание для отдельных объектов и в среднем по выборке\nВажный признак — тот, без которого модель начинает хуже предсказывать.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 124,
      "question": "Что такое baseline модель?",
      "answer": "Это самая простая модель (например, среднее или медиана), служащая отправной точкой для оценки улучшений.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 125,
      "question": "Как работает кросс-валидация и зачем она нужна?",
      "answer": "Кросс-валидация — это способ оценки качества модели, при котором данные делят на `k` частей (фолдов). Модель обучают `k` раз: каждый раз один фолд используется для валидации, а остальные — для обучения.\n\nКросс-валидация нужна, чтобы:\n\n- получить более стабильную оценку качества\n- уменьшить зависимость результата от случайного разбиения данных\n- лучше оценить обобщающую способность модели",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 126,
      "question": "Когда линейная регрессия неприменима?",
      "answer": "Линейная регрессия становится неприемлемой, когда её базовые предположения нарушены и это нельзя исправить простыми приёмами. Основные случаи:\n\n- Нелинейная связь между признаками и целевой переменной\n- Сильная мультиколлинеарность, делающая коэффициенты нестабильными\n- Гетероскедастичность, при которой дисперсия ошибок зависит от признаков\n- Ненормальность остатков, если она критична для выводов и доверительных интервалов\n\nЕсли данные ведут себя не линейно — линейная регрессия начинает врать.  \nВ таких ситуациях применяют другие модели.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 127,
      "question": "Что такое Гетероскедастичность?",
      "answer": "Гетероскедастичность — это когда разброс ошибок НЕ одинаков. Например предсказываем доход по стажу: стаж 1-2 года → доходы ±5k, стаж 20 лет → доходы ±100k. Разброс и ошибки растут вместе с признаком, в нашем примере со стажем. \n\nЛинейная регрессия предполагает что ошибки имеют постоянную дисперсию, или отсутствие Гетероскедастичности.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Статистика"
    },
    {
      "id": 128,
      "question": "Что такое Логистическая регрессия?",
      "answer": "Логистическая регрессия — это линейная модель классификации, которая оценивает вероятность принадлежности объекта к классу с помощью взвешенной суммы признаков и сигмоидной функции.\n\nПроводит «линию» (или гиперплоскость) между классами и говорит, по какую сторону объект находится.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 129,
      "question": "Что такое Дерево решений?",
      "answer": "Дерево решений — это нелинейная модель, которая последовательно делит данные на группы с помощью правил вида «если признак ≤ значение».\n\nЗадаёт цепочку вопросов и по ним принимает решение.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 130,
      "question": "Когда логистическая регрессия предпочтительнее дерева решений?",
      "answer": "Логистическая регрессия предпочтительнее, когда:\n- классы примерно линейно разделимы\n- важна интерпретируемость и влияние каждого признака\n- данные зашумлены и нужно устойчивое решение\n- требуется стабильная, воспроизводимая модель\n    \nДеревья решений лучше подходят для сложных нелинейных зависимостей, но чаще переобучаются.\n\nЛогистическая регрессия — простая и стабильная.    \nДерево — гибкое, но легко переобучается.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 131,
      "question": "Что такое логистическая функция?",
      "answer": "Логистическая функция (sigmoid) — это функция, которая преобразует любое вещественное число в значение от 0 до 1. Обычно используется для интерпретации результата модели как вероятности. Формула: $σ(x) = \\frac{1}{1 \\ + \\ e^{−x}}$\n\nЛогистическая функция «сжимает» любое число в диапазон вероятностей от 0 до 1.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 132,
      "question": "Как бороться с дисбалансом классов?",
      "answer": "С дисбалансом классов борются, чтобы модель не игнорировала редкий, но важный класс. Основные подходы:\n- Взвешивание классов — увеличивает штраф за ошибки на редком классе\n- Oversampling — увеличивает число объектов редкого класса\n- Undersampling — уменьшает число объектов частого класса\n- Корректные метрики — используют precision, recall, F1, PR-AUC вместо accuracy\n- Подбор порога — выбирают порог классификации под бизнес-цель",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 133,
      "question": "Для чего нужен валидационный набор?",
      "answer": "Валидационный набор используется для оценки модели в процессе обучения и подбора гиперпараметров.\n\nНужен, чтобы настраивать гиперпараметры модели, контролировать переобучение, выбирать момент остановки обучения (early stopping), сравнивать разные модели и конфигурации.\n\nТрейн учит модель, валидация подсказывает, когда и как её учить лучше.",
      "tags": [],
      "level": "lvl_1",
      "topic": "ML"
    },
    {
      "id": 134,
      "question": "Что показывает learning curve?",
      "answer": "Learning curve — это график зависимости качества модели от размера обучающей выборки. По learning curve можно понять:\n- хватает ли данных для обучения\n- есть ли переобучение или недообучение\n- поможет ли добавление новых данных\n- ограничено ли качество моделью или данными\n\nОбычно смотрят кривые train и validation.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 135,
      "question": "Что делает k-fold кросс-валидация?",
      "answer": "k-fold кросс-валидация делит данные на k частей (фолдов) и обучает модель k раз, каждый раз используя один фолд для валидации, а остальные — для обучения.\n\nМетод позволяет:\n- усреднить качество по разным разбиениям\n- снизить дисперсию оценки\n- получить более надёжную оценку обобщающей способности модели\n\nk-fold проверяет модель на разных кусках данных, а не на одном случайном разбиении.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 136,
      "question": "Чем отличается дерево решений от случайного леса?",
      "answer": "Дерево решений — это одна модель, которая последовательно делит данные по правилам. Она проста и интерпретируема, но легко переобучается.\n\nСлучайный лес — это ансамбль деревьев решений, обученных на разных подвыборках данных и случайных подмножествах признаков. Такой подход снижает переобучение и делает модель более устойчивой, но менее интерпретируемой.\n\nОдно дерево — быстро и понятно, но нестабильно.  \nЛес — надёжнее за счёт усреднения многих деревьев.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 137,
      "question": "Как устроен градиентный бустинг?",
      "answer": "Градиентный бустинг — это ансамблевый метод, в котором модели обучаются последовательно. Каждая новая модель обучается на ошибках предыдущих, аппроксимируя отрицательный градиент функции потерь и тем самым уменьшая общий лосс.\n\nГрадиентный бустинг — это последовательное исправление ошибок модели шаг за шагом в сторону минимума функции потерь.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 138,
      "question": "Что такое регуляризация в линейной модели?",
      "answer": "Регуляризация — это добавление штрафа к функции потерь, которое ограничивает величину коэффициентов модели и снижает переобучение. Основные виды:\n- L1 (Lasso) — штрафует сумму модулей весов, может занулять коэффициенты\n- L2 (Ridge) — штрафует сумму квадратов весов, делает веса меньше и стабильнее\n    \nРегуляризация не даёт коэффициентам “раздуваться” и подгоняться под шум.",
      "tags": [],
      "level": "lvl_2",
      "topic": "ML"
    },
    {
      "id": 139,
      "question": "Как интерпретировать коэффициенты логистической регрессии?",
      "answer": "В логистической регрессии коэффициент показывает, на сколько изменяется логарифм отношения шансов принадлежности к классу 1 при увеличении признака на одну единицу при прочих равных.\n\nКоэффициенты логистической регрессии говорят не о вероятностях напрямую, а о том, как признаки усиливают или ослабляют шансы класса.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 140,
      "question": "Как интерпретировать Shapley (SHAP) values?",
      "answer": "SHAP values показывают, какой вклад каждый признак внёс в предсказание модели для конкретного объекта по сравнению с базовым значением.\n\nИнтерпретация:\n- положительное SHAP-значение — признак увеличил предсказание\n- отрицательное — признак уменьшил предсказание\n- сумма SHAP-значений всех признаков равна разнице между предсказанием и базовым уровнем\n    \nSHAP основан на идее справедливого распределения вклада и учитывает все возможные комбинации признаков, поэтому на практике используется в виде приближений.\n\nSHAP отвечает на вопрос: “кто и на сколько повлиял на это предсказание?”",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 141,
      "question": "Что такое утечка признаков и как её избежать?",
      "answer": "Утечка признаков (data leakage) — это ситуация, когда модель получает информацию, которая недоступна на момент предсказания или напрямую связана с целевой переменной. В результате качество на обучении и валидации завышено, а в проде модель работает плохо.\n\nЧтобы избежать утечки:\n- строго разделяют данные на train / validation / test\n- не используют признаки, появляющиеся после целевого события\n- выполняют feature engineering отдельно внутри каждого разбиения\n- аккуратно работают с временными данными и агрегатами\n\nЕсли признак “знает будущее”, модель будет обманывать.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 142,
      "question": "В чём разница между bagging и boosting?",
      "answer": "Bagging (Bootstrap Aggregating) обучает несколько моделей параллельно на разных бутстрэп-выборках и усредняет их предсказания. Основная цель — снизить дисперсию и переобучение.\n\nBoosting обучает модели последовательно: каждая новая модель фокусируется на ошибках предыдущих. Основная цель — уменьшить смещение (bias) и повысить качество.\n\nBagging — много независимых мнений и усреднение.  \nBoosting — поэтапное исправление ошибок.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 143,
      "question": "Зачем стандартизировать признаки перед PCA?",
      "answer": "PCA чувствителен к масштабу признаков, так как ищет направления с максимальной дисперсией. Если признаки измеряются в разных единицах, признаки с большой дисперсией будут доминировать и искажать главные компоненты.\n\nСтандартизация (приведение к нулевому среднему и единичной дисперсии) делает вклад признаков сопоставимым и позволяет PCA отражать реальную структуру данных, а не различия в масштабе.\n\nБез стандартизации PCA выделяет “крупные по масштабу” признаки, а не действительно важные.",
      "tags": [],
      "level": "lvl_3",
      "topic": "ML"
    },
    {
      "id": 144,
      "question": "Как работает list comprehension и чем он лучше цикла?",
      "answer": "List comprehension — это краткий синтаксис создания списка на основе другого итерируемого объекта с возможной фильтрацией и преобразованием элементов.\n\n- код становится короче и читабельнее\n- операции выполняются быстрее за счёт оптимизаций на уровне интерпретатора\n- удобно выражать простые преобразования коллекций\n    \nList comprehension лучше использовать для простых выражений, сложную логику — оставлять в циклах.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Python"
    },
    {
      "id": 145,
      "question": "Чем полезен `enumerate` при обходе списка?",
      "answer": "`enumerate` позволяет итерироваться по коллекции, одновременно получая индекс и значение элемента.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Python"
    },
    {
      "id": 146,
      "question": "Какой тип коллекции в Python является неизменяемым?",
      "answer": "`tuple` — кортеж, неизменяемая коллекция в Python, после создания его элементы нельзя изменить, добавить или удалить.\n\n`frozenset` — неизменяемая версия множества\n    \n`str` — строка (последовательность символов)",
      "tags": [],
      "level": "lvl_1",
      "topic": "Python"
    },
    {
      "id": 147,
      "question": "Как проверить, содержится ли ключ в словаре без выброса исключения?",
      "answer": "Оператор `in` в конструкции `key in my_dict` проверяет наличие ключа по хеш-таблице.",
      "tags": [],
      "level": "lvl_1",
      "topic": "Python"
    },
    {
      "id": 148,
      "question": "Как удалить дубликаты в Pandas?",
      "answer": "Для удаления дубликатов в Pandas используют метод `drop_duplicates()`.\n\n- удаляет дубликаты по всем столбцам\n- удаляет дубликаты по выбранным столбцам (`subset`)\n- оставляет первое или последнее вхождение",
      "tags": [],
      "level": "lvl_1",
      "topic": "Python"
    },
    {
      "id": 149,
      "question": "Как устроен GIL и почему он не даёт линейного ускорения в потоках?",
      "answer": "GIL (Global Interpreter Lock) — это механизм в CPython, который позволяет исполняться только одному байткоду Python одновременно.\n\nИз-за GIL — CPU-bound задачи в потоках не ускоряются, потоки по очереди получают доступ к интерпретатору\n\nGIL мешает параллельным вычислениям CPU, но не мешает ожиданию I/O. Для реального параллелизма CPU-bound задач используют multiprocessing.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 150,
      "question": "Зачем использовать `typing` и чем он полезен аналитикам?",
      "answer": "`typing` позволяет явно указывать типы переменных, аргументов функций и возвращаемых значений.\n\nОн помогает аналитикам:\n- улучшает читаемость и самодокументируемость кода\n- дает более точное автодополнение в IDE\n- находит ошибки типов до выполнения кода с помощью `mypy`\n- упрощает code review и поддержку аналитических скриптов",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 151,
      "question": "Чем отличается `asyncio` от `multiprocessing` в ETL-конвейере?",
      "answer": "`asyncio` используется для параллельной обработки I/O-bound шагов (запросы к API, БД, файлам) в одном процессе. Оно эффективно скрывает задержки ввода/вывода, но не ускоряет вычисления.\n\n`multiprocessing` запускает несколько процессов и подходит для CPU-bound шагов, так как не ограничен GIL и позволяет задействовать несколько ядер.\n\nВ ETL-конвейерах их часто комбинируют:  \nасинхронная загрузка данных + параллельная обработка в процессах.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 152,
      "question": "Как уменьшить использование памяти при обработке CSV в pandas?",
      "answer": "Чтобы снизить потребление памяти при чтении CSV в pandas:\n\n- Явно указать `dtypes` — предотвращает автоматическое приведение к более тяжёлым типам\n- Использовать `chunksize` — читать файл частями и обрабатывать потоково\n- Использовать `usecols` — загружать только нужные столбцы\n- По возможности приводить строки к `category`",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 153,
      "question": "Как работает `functools.lru_cache`?",
      "answer": "`lru_cache` — это декоратор, который кэширует результаты вызовов функции по её аргументам и возвращает сохранённый результат при повторном вызове.\n\n- использует стратегию LRU (Least Recently Used) — вытесняет давно неиспользуемые значения\n- сильно ускоряет повторяющиеся вычисления, особенно в рекурсии\n- размер кэша можно ограничить параметром `maxsize`\n    \nПрименяется, когда функция детерминирована и часто вызывается с одинаковыми аргументами.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 154,
      "question": "Чем отличаются списки и кортежи в Python?",
      "answer": "Списки (`list`) — изменяемые последовательности: элементы можно добавлять, удалять и менять. Они имеют больше методов и подходят для работы с данными, которые меняются.\n\nКортежи (`tuple`) — неизменяемые последовательности: после создания их нельзя изменить. Они занимают меньше памяти, быстрее обрабатываются и могут использоваться как ключи словаря (если содержат только хэшируемые элементы).",
      "tags": [],
      "level": "lvl_1",
      "topic": "Python"
    },
    {
      "id": 155,
      "question": "Что такое генератор и чем он отличается от списка в Python?",
      "answer": "Генератор — это итерируемый объект, который вычисляет элементы по одному при обходе, не сохраняя их все в памяти.\n\nОтличия от списка:\n\n- генератор ленивый и экономит память\n- список вычисляет и хранит все элементы сразу\n- генератор можно пройти только один раз\n    \nГенераторы удобны для обработки больших или бесконечных последовательностей.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 156,
      "question": "В чём разница между `copy` и `deepcopy`?",
      "answer": "`copy` создаёт поверхностную копию объекта: копируется только сам контейнер, а вложенные объекты остаются общими по ссылке.\n\n`deepcopy` создаёт глубокую копию: рекурсивно копирует все вложенные объекты, формируя полностью независимую структуру данных.\n\n`deepcopy` используют, когда нужно изменить копию, не затрагивая исходный объект.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 157,
      "question": "Когда использовать `pandas.merge`, а когда `pandas.join`?",
      "answer": "`merge` — универсальный способ объединения DataFrame:\n- объединяет по столбцам, даже если их имена различаются\n- подходит для большинства SQL-подобных join’ов (`inner`, `left`, `right`, `outer`)\n- явно указывает ключи (`left_on`, `right_on`)\n    \n`join` — упрощённый синтаксис:\n- по умолчанию объединяет по индексам\n- удобен, когда ключ уже является индексом\n- короче и читабельнее в простых случаях",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 158,
      "question": "Как работает `itertools.groupby` и в чём его ограничение?",
      "answer": "`itertools.groupby` группирует последовательно идущие элементы по значению ключа и возвращает пары (ключ, итератор по группе).\n\nОграничения:\n- группирует только соседние элементы, а не все одинаковые значения\n- для корректной глобальной группировки данные нужно предварительно отсортировать\n- возвращаемые группы — итераторы, которые нужно потреблять сразу\n    \n`groupby` работает как «сжатие подряд идущих значений», а не как SQL GROUP BY.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 159,
      "question": "В чём разница между итератором и генератором в Python?",
      "answer": "Итератор — это объект, который реализует протокол итерации (`__iter__()` и `__next__()`) и возвращает элементы по одному при обходе.\n\nГенератор — это удобный способ создания итератора, который определяется функцией с `yield`, автоматически хранит состояние между вызовами, не требует явной реализации `__next__()`.\n    \nИтератор — это интерфейс.   \nГенератор — это частный случай итератора, реализованный проще и компактнее.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Python"
    },
    {
      "id": 160,
      "question": "Как быстро собрать интерактивный прототип дашборда без BI-систем?",
      "answer": "Для быстрого прототипирования интерактивных дашбордов используют Python-фреймворки Dash, Streamlit или Panel.\n\nUI собираем во фреймворке, логику расчёта метрик держим отдельно, кешируем тяжёлые вычисления, фиксируем зависимости в `requirements.txt`.\n    \nТакой подход позволяет быстро показать результат и безболезненно перенести прототип в прод.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 161,
      "question": "Как безопасно работать с конфиденциальными переменными окружения?",
      "answer": "Конфиденциальные данные (API-ключи, пароли, токены) хранят в переменных окружения, а не в коде. Рекумендуется:\n\n- использовать `.env` и загрузку через `dotenv` или системные секреты\n- не коммитить `.env` в репозиторий\n- получать значения через `os.environ`\n- добавлять `.env.example` с перечнем переменных без значений",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 162,
      "question": "Какой модуль используют для сериализации объектов в JSON в Python?",
      "answer": "Для сериализации данных в JSON используют стандартный модуль `json`, это стандартный способ превратить Python-данные в формат для обмена и хранения.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 163,
      "question": "Как посчитать среднее значение столбца в Pandas без учёта NaN?",
      "answer": "В pandas метод `mean()` по умолчанию игнорирует NaN. \n\nПри необходимости поведение можно зафиксировать явно: `df['col'].mean(skipna=True)`. Это гарантирует, что пропущенные значения не участвуют в расчёте среднего.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 164,
      "question": "Как зафиксировать версию зависимостей для проекта?",
      "answer": "`pip freeze > requirements.txt` — выписывает фактические версии установленных пакетов в файл requirements.txt.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 165,
      "question": "Чем отличается `loc` от `iloc` в Pandas?",
      "answer": "`loc` использует метки строк и столбцов: `df.loc['A', 'value']`   \n`iloc` использует целочисленные позиции: `df.iloc[0, 1]`",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 166,
      "question": "Как безопасно открывать и закрывать файлы в Python?",
      "answer": "Для безопасной работы с файлами используют контекстный менеджер `with`. Он гарантирует, что файл будет автоматически закрыт, даже если во время работы возникнет ошибка.\n\n```python\nwith open('data.txt', 'r') as f:\n    data = f.read()\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 167,
      "question": "Что происходит при использовании mutable default аргумента?",
      "answer": "Если в качестве значения по умолчанию используется изменяемый объект, он создаётся один раз при объявлении функции и переиспользуется во всех последующих вызовах.\n\nПоэтому изменения (например, `append`) накапливаются между вызовами функции, что часто приводит к неожиданному поведению.\n\nПравильный подход — использовать `None` и создавать объект внутри функции.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 168,
      "question": "Как работает `zip_longest` из `itertools`?",
      "answer": "`zip_longest` объединяет элементы нескольких итерируемых объектов по индексам и продолжается до самого длинного из них. Если элементы в одном из итерируемых закончились, вместо них подставляется значение `fillvalue`.\n\n```python\nzip_longest([1, 2], ['a'], fillvalue='-')  # → (1, 'a'), (2, '-')\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 169,
      "question": "Как работает `Counter.most_common`?",
      "answer": "Метод `most_common(n)` возвращает `n` элементов с наибольшей частотой из объекта `Counter` в виде пар `(элемент, количество)`. Элементы отсортированы по убыванию частоты.\n\n```python\nCounter('abbccc').most_common(2) # [('c', 3), ('b', 2)]\n```",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 170,
      "question": "Как работает `pathlib` при построении путей?",
      "answer": "Модуль `pathlib` позволяет строить файловые пути с помощью объектов `Path`. Оператор `/` соединяет части пути, автоматически подставляя корректный разделитель для текущей ОС. Избавляет от ручной сборки путей и ошибок с разделителями.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 171,
      "question": "Что происходит при использовании `Decimal` для денежных расчётов?",
      "answer": "Тип `Decimal` хранит числа в точном десятичном виде, поэтому операции с денежными суммами выполняются без ошибок округления, характерных для `float`.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 172,
      "question": "Что происходит при использовании `pandas.assign`?",
      "answer": "Метод `assign` добавляет новый столбец в DataFrame и возвращает копию, не изменяя исходный объект без явного присваивания. Удобно использовать в цепочках преобразований данных.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 173,
      "question": "Что делает метод `DataFrame.pipe`?",
      "answer": "Метод `pipe` позволяет применять функции к DataFrame внутри цепочки вызовов, передавая DataFrame в функцию как аргумент.\n\nЭто упрощает построение читаемых конвейеров обработки данных и разделение логики на шаги.\n\n`pipe` — это способ писать pandas-код как последовательный конвейер шагов.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 174,
      "question": "Что делает `asyncio.gather`?",
      "answer": "`asyncio.gather()` запускает несколько корутин (управляемая функция, которая умеет ждать) конкурентно и ожидает их завершения, возвращая список результатов в порядке передачи.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 175,
      "question": "Как работает `csv.DictWriter` при записи отчётов?",
      "answer": "`csv.DictWriter` записывает CSV-файл из списка словарей, где ключи соответствуют именам столбцов. Полезен когда данные уже в виде словарей и важны имена колонок.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 176,
      "question": "В чём разница между `multiprocessing` и `threading` для аналитических задач?",
      "answer": "`threading` запускает несколько потоков в одном процессе и подходит для I/O-bound задач, так как в CPython потоки ограничены GIL и не ускоряют вычисления.\n\n`multiprocessing` создаёт отдельные процессы, каждый со своим интерпретатором, что позволяет параллелить CPU-bound расчёты, но требует больше памяти и накладных расходов.\n\nВыбор зависит от типа нагрузки: ожидание ввода/вывода или интенсивные вычисления.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 177,
      "question": "Зачем использовать `pyarrow` / `parquet` при выгрузке данных?",
      "answer": "Parquet — колоночный формат хранения данных со сжатием и явной схемой, оптимизированный для аналитики. PyArrow — это Python-библиотека для работы с форматом Parquet. Использование `pyarrow` и Parquet позволяет:\n\n- значительно уменьшить размер данных\n- ускорить чтение и запись больших таблиц\n- читать только нужные столбцы\n- легко интегрироваться с pandas и аналитическими движками\n    \nПо сравнению с CSV, Parquet быстрее, компактнее и масштабируется лучше.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 178,
      "question": "Когда стоит предпочесть векторизованный Pandas API вместо `apply`?",
      "answer": "Векторизованные операции в pandas выполняются на уровне C/NumPy и обрабатывают массивы целиком, поэтому они значительно быстрее, чем `apply` с Python-функцией по строкам. \n\n`apply` стоит использовать только тогда, когда логику невозможно выразить векторизованно, требуется сложная Python-логика для каждой строки\n    \nВо всех остальных случаях предпочтительны векторизованные операции.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 179,
      "question": "Что даёт `typing.Literal` и когда его применять?",
      "answer": "`typing.Literal` позволяет ограничить значение аргумента конкретным набором допустимых значений (строк, чисел, булевых).\n\nИспользуется, когда параметр может принимать строго фиксированные варианты (режимы, флаги), важно избежать опечаток и невалидных значений.\n    \n `Literal` — это самозапрет типа «разрешены только эти значения».",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 180,
      "question": "Когда следует использовать `pathlib` вместо `os.path`?",
      "answer": "`pathlib` стоит использовать в большинстве новых проектов, когда нужна удобная и безопасная работа с путями.\n\n`os.path` чаще встречается в легаси-коде или низкоуровневых скриптах.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 181,
      "question": "Что такое `pandas.eval` и чем он полезен?",
      "answer": "`pandas.eval` выполняет выражения над данными с использованием оптимизированного вычислительного движка (`numexpr`), что может ускорять операции на больших DataFrame.\n\n`pandas.eval` полезен для сложных арифметических выражений, но не заменяет стандартный векторизованный API.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 182,
      "question": "Почему важно фиксировать `random seed` в экспериментах?",
      "answer": "Фиксация `random seed` делает результаты экспериментов воспроизводимыми. \n\nЭто позволяет получать одинаковые разбиения `train / test`, повторять результаты bootstrap и симуляций, корректно сравнивать модели и гиперпараметры, упростить отладку и code review.\n    \nБез фиксированного seed небольшие изменения могут приводить к разным результатам, затрудняя анализ.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 183,
      "question": "Почему стоит избегать chained assignment в pandas?",
      "answer": "Chained assignment — это присваивание, в котором данные выбираются и изменяются в несколько шагов подряд через цепочку индексаций.\n\nChained assignment может привести к неявным ошибкам, так как pandas не гарантирует, что изменение будет применено к исходному DataFrame.\n\nРекомендуется использовать `loc` для явного присваивания, и `assign` для немутирующих преобразований.\n    \nЕсли не ясно, что именно меняется — значит, код опасен.",
      "tags": [],
      "level": "lvl_2",
      "topic": "Python"
    },
    {
      "id": 184,
      "question": "Как реализовать детерминированное сплитование пользователей для эксперимента?",
      "answer": "Детерминированное сплитование — это распределение пользователей по группам так, что один и тот же пользователь всегда попадает в одну и ту же группу. Для этого используют хеширование `user_id` с добавлением соли (идентификатора эксперимента):\n\n```python\ndef bucket(user_id, salt, buckets=100):     \n\treturn hash(f\"{user_id}{salt}\") % buckets\n```\n\nХэш преобразует `user_id` в число, а остаток от деления (`% buckets`) определяет номер бакета. Такое решение обеспечивает стабильное и воспроизводимое распределение без хранения данных в БД.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Python"
    },
    {
      "id": 185,
      "question": "Как быстро оценить MDE в Python?",
      "answer": "MDE (Minimum Detectable Effect) — минимальный эффект, который эксперимент может обнаружить при заданном уровне значимости и размере выборки.\n\nПри нормальном приближении MDE оценивают по формуле: $MDE = z_{α/2} · σ · √(2 / n)$\n\n\n```python\nfrom scipy import stats \nimport math  \n\ndef mde(sigma, n, alpha=0.05):     \n\treturn stats.norm.ppf(1 - alpha / 2) * sigma * math.sqrt(2 / n)\n```\n\nMDE используют для проверки, имеет ли эксперимент смысл при данном размере данных.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Python"
    },
    {
      "id": 186,
      "question": "Как проверить качество рандомизации с помощью pandas?",
      "answer": "Качество рандомизации проверяют, сравнивая базовые признаки пользователей между экспериментальными группами.\n\nТиповой подход собрать DataFrame с признаком группы (A/B) и пользовательскими фичами, посчитать агрегаты через `groupby + agg` (mean, std, count), проверить статистические различия:\n- `ttest_ind` — для числовых признаков\n- χ²-тест — для категориальных\n        \nЕсли различий нет, рандомизация считается корректной.",
      "tags": [],
      "level": "lvl_3",
      "topic": "Python"
    }
  ]
}